from typing import List, Dict, Any, Optional

from .exceptions import WorkflowError, InvalidActionError, WorkflowValidationError
from . import actions # Import action type constants

class WorkflowBuilder:
    """
    Provides a fluent, chainable interface to programmatically construct 
    workflow definitions that are compatible with the Stagehand interaction engine.

    Workflows are built by calling action methods (e.g., navigate, click, type_text)
    and then finalized with the `build()` method to produce a payload dictionary 
    suitable for `StagehandClient.create_task()`.

    Key Features:
      - Chainable methods for adding common web interaction steps.
      - Basic input validation for action parameters.
      - Generates a structured dictionary representing the workflow.
      - Helper methods for inspecting the defined steps.

    Example:
        >>> from src.workflow_system import WorkflowBuilder # Assuming project root is in PYTHONPATH
        >>> builder = WorkflowBuilder(workflow_name="MyLoginFlow")
        >>> payload = (builder
        ...     .navigate("https://example.com/login")
        ...     .type_text("#username", "testuser")
        ...     .type_text("#password", "securepass")
        ...     .click("button[type=submit]")
        ...     .wait_for_selector(".dashboard-greeting", timeout=5000)
        ...     .build())
        >>> print(payload['name'])
        MyLoginFlow
        >>> len(payload['steps'])
        5
    """
    def __init__(self, workflow_name: str):
        """
        Initializes a new WorkflowBuilder instance.

        The workflow name is used to identify the workflow and will be included 
        in the final payload generated by the `build()` method.

        Args:
            workflow_name (str): The name of the workflow. Must be a non-empty string.

        Raises:
            WorkflowError: If `workflow_name` is empty or not a string.
        """
        if not workflow_name or not isinstance(workflow_name, str):
            raise WorkflowError("Workflow name must be a non-empty string.")
        self.workflow_name: str = workflow_name
        self._steps: List[Dict[str, Any]] = []

    def _add_step(self, action_type: str, params: Dict[str, Any]) -> 'WorkflowBuilder':
        """Internal helper to add a generic action step to the workflow.
        Each step is represented as a dictionary formatted for Stagehand.

        Args:
            action_type: The string identifier for the action (e.g., actions.NAVIGATE).
            params: A dictionary of parameters specific to this action type.

        Returns:
            The WorkflowBuilder instance for method chaining.
        """
        step = {
            "type": "action", # Per PRD, Stagehand output has this. Assume input is similar.
            "actionType": action_type,
            **params
        }
        self._steps.append(step)
        return self

    # --- Chainable Action Methods ---

    def navigate(self, url: str) -> 'WorkflowBuilder':
        """
        Adds a navigation step to the workflow.
        Instructs the browser to navigate to the specified URL.

        Args:
            url (str): The absolute URL to navigate to.

        Returns:
            WorkflowBuilder: The WorkflowBuilder instance for method chaining.

        Raises:
            InvalidActionError: If the URL is empty or not a string.
        """
        if not url or not isinstance(url, str):
            raise InvalidActionError("URL must be a non-empty string for navigate action.")
        return self._add_step(actions.NAVIGATE, {"url": url})

    def click(self, selector: str, text_content_match: Optional[str] = None) -> 'WorkflowBuilder':
        """
        Adds a click step to the workflow.
        Instructs the browser to click on an element matching the CSS selector.

        Args:
            selector (str): CSS selector to identify the element to click.
            text_content_match (Optional[str]): If provided, clicks the element only 
                if its text content matches this string. Defaults to None.

        Returns:
            WorkflowBuilder: The WorkflowBuilder instance for method chaining.

        Raises:
            InvalidActionError: If `selector` is empty/invalid or `text_content_match` 
                              is not a string (if provided).
        """
        if not selector or not isinstance(selector, str):
            raise InvalidActionError("Selector must be a non-empty string for click action.")
        params = {"selector": selector}
        if text_content_match is not None:
            if not isinstance(text_content_match, str):
                raise InvalidActionError("text_content_match must be a string if provided.")
            params["textContentMatch"] = text_content_match
        return self._add_step(actions.CLICK, params)

    def type_text(self, selector: str, text_to_type: str, clear_before_type: bool = False) -> 'WorkflowBuilder':
        """
        Adds a text typing step to the workflow.
        Instructs the browser to type the specified text into an element 
        identified by the CSS selector.

        Args:
            selector (str): CSS selector for the input field or textarea.
            text_to_type (str): The text to type into the element.
            clear_before_type (bool): Optional (default=False). If True, attempts to clear 
                                    the field before typing. (Assumes Stagehand support 
                                    for this parameter).

        Returns:
            WorkflowBuilder: The WorkflowBuilder instance for method chaining.

        Raises:
            InvalidActionError: If `selector` is empty/invalid or `text_to_type` is not a string.
        """
        if not selector or not isinstance(selector, str):
            raise InvalidActionError("Selector must be a non-empty string for type_text action.")
        if not isinstance(text_to_type, str):
            raise InvalidActionError("Text to type must be a string for type_text action.")
        params = {"selector": selector, "text": text_to_type}
        if clear_before_type:
            params["clearBefore"] = True # Assuming Stagehand supports this
        return self._add_step(actions.TYPE, params)

    def wait_for_selector(self, selector: str, timeout: int = 30000, visible: Optional[bool] = None) -> 'WorkflowBuilder':
        """
        Adds a step to wait for an element to match a condition.

        This typically means waiting for an element identified by the CSS selector 
        to be present in the DOM. The `visible` parameter can further specify 
        waiting for visibility state.

        Args:
            selector (str): CSS selector for the element to wait for.
            timeout (int): Optional. Maximum time to wait in milliseconds. 
                           Defaults to 30000 (30 seconds).
            visible (Optional[bool]): Optional. 
                - If True, waits for the element to be present and visible.
                - If False, might wait for the element to be hidden or not present 
                  (exact behavior depends on Stagehand implementation).
                - If None (default), typically waits for presence in the DOM, 
                  visibility may not be guaranteed or checked.

        Returns:
            WorkflowBuilder: The WorkflowBuilder instance for method chaining.

        Raises:
            InvalidActionError: If `selector` is empty/invalid or `timeout` is invalid.
        """
        if not selector or not isinstance(selector, str):
            raise InvalidActionError("Selector must be a non-empty string for wait_for_selector.")
        if not isinstance(timeout, int) or timeout < 0:
            raise InvalidActionError("Timeout must be a non-negative integer (milliseconds).")
        params = {"selector": selector, "timeout": timeout}
        if visible is not None:
            params["visible"] = bool(visible) # Ensure boolean
        return self._add_step(actions.WAIT_FOR_SELECTOR, params)

    def wait_for_time(self, duration_ms: int) -> 'WorkflowBuilder':
        """
        Adds a fixed wait (or sleep) step to the workflow.
        This is a pause for a specified duration.

        Args:
            duration_ms (int): The duration to wait, in milliseconds.

        Returns:
            WorkflowBuilder: The WorkflowBuilder instance for method chaining.

        Raises:
            InvalidActionError: If `duration_ms` is not a positive integer.
        """
        if not isinstance(duration_ms, int) or duration_ms <= 0:
            raise InvalidActionError("Duration must be a positive integer (milliseconds) for wait_for_time.")
        return self._add_step(actions.WAIT_FOR_TIME, {"duration": duration_ms})

    def extract_text(self, selector: str, attribute: Optional[str] = None, variable_name: Optional[str] = None) -> 'WorkflowBuilder':
        """
        Adds a step to extract text content or an attribute from an element.
        
        The extracted value can optionally be stored in a workflow variable 
        (e.g., for use in later steps or assertions), assuming Stagehand supports 
        such a variable system and the specified `variable_name`.

        Args:
            selector (str): CSS selector for the element from which to extract.
            attribute (Optional[str]): If provided, extracts the value of this HTML attribute 
                                     (e.g., "href", "src", "value") instead of the 
                                     element's visible text content. Defaults to None.
            variable_name (Optional[str]): If provided, Stagehand might store the extracted 
                                         value in a context variable with this name. 
                                         Defaults to None.

        Returns:
            WorkflowBuilder: The WorkflowBuilder instance for method chaining.

        Raises:
            InvalidActionError: If `selector` is empty/invalid, or if `attribute` or 
                              `variable_name` are invalid (if provided).
        """
        if not selector or not isinstance(selector, str):
            raise InvalidActionError("Selector must be a non-empty string for extract_text.")
        params: Dict[str, Any] = {"selector": selector}
        if attribute is not None:
            if not isinstance(attribute, str) or not attribute.strip():
                raise InvalidActionError("Attribute must be a non-empty string if provided.")
            params["attribute"] = attribute.strip()
        if variable_name is not None:
            if not isinstance(variable_name, str) or not variable_name.strip():
                raise InvalidActionError("Variable name must be a non-empty string if provided.")
            params["variableName"] = variable_name.strip()
        return self._add_step(actions.EXTRACT_TEXT, params)

    def scroll(self, direction: str, amount_pixels: Optional[int] = None, selector_to_element: Optional[str] = None) -> 'WorkflowBuilder':
        """
        Adds a scroll step to the workflow.

        Can scroll in a specific direction by a number of pixels, scroll to make a 
        specific element visible, or perform page-level scrolls (e.g., page down, end).

        Args:
            direction (str): The direction/type of scroll. Supported values include:
                             "up", "down", "left", "right", "to_element", 
                             "page_down", "page_up", "home", "end".
            amount_pixels (Optional[int]): For directional scrolls ("up", "down", "left", 
                                         "right"), the number of pixels to scroll. 
                                         Must be a positive integer if provided.
            selector_to_element (Optional[str]): For "to_element" direction, the CSS 
                                               selector of the target element to scroll to.

        Returns:
            WorkflowBuilder: The WorkflowBuilder instance for method chaining.

        Raises:
            InvalidActionError: For invalid `direction` or missing/invalid parameters 
                              for certain directions (e.g., missing `selector_to_element` 
                              for "to_element" scroll, or invalid `amount_pixels`).
        """
        valid_directions = ["up", "down", "left", "right", "to_element", "page_down", "page_up", "home", "end"]
        if direction not in valid_directions:
            raise InvalidActionError(f"Invalid scroll direction '{direction}'. Must be one of {valid_directions}")
        
        params: Dict[str, Any] = {"direction": direction}
        if direction == "to_element":
            if not selector_to_element or not isinstance(selector_to_element, str):
                raise InvalidActionError("selector_to_element is required for 'to_element' scroll direction.")
            params["selector"] = selector_to_element
        # Corrected logic for amount_pixels: only relevant for specific directions
        elif direction in ["up", "down", "left", "right"]:
            if amount_pixels is not None:
                if not isinstance(amount_pixels, int) or amount_pixels <= 0:
                    raise InvalidActionError("amount_pixels must be a positive integer if provided for scroll.")
                params["amount"] = amount_pixels
            # else: if amount_pixels is None for these directions, Stagehand might use a default scroll amount
        elif amount_pixels is not None and direction not in ["up", "down", "left", "right"]:
            # amount_pixels provided but not for a direction that uses it or needs it.
            raise InvalidActionError(f"amount_pixels is not applicable for scroll direction '{direction}'.")
        
        return self._add_step(actions.SCROLL, params)

    def assert_element(self, selector: str, exists: bool = True, is_visible: Optional[bool] = None) -> 'WorkflowBuilder':
        """
        Adds an assertion step to check for an element's existence or visibility state.
        
        This assumes Stagehand supports assertion actions that can influence 
        workflow execution (e.g., halt on failure or log an assertion result).

        Args:
            selector (str): CSS selector for the element to assert.
            exists (bool): Optional (default=True). 
                           If True, asserts the element exists.
                           If False, asserts the element does NOT exist.
            is_visible (Optional[bool]): Optional. 
                - If True, asserts the element is present and visible.
                - If False, asserts the element is present but not visible, or not present at all 
                  (exact behavior may depend on Stagehand's interpretation of "not visible" 
                  when `exists` is True).
                - If None (default), only existence as per the `exists` parameter is checked.

        Returns:
            WorkflowBuilder: The WorkflowBuilder instance for method chaining.

        Raises:
            InvalidActionError: If `selector` is empty or invalid.
        """
        if not selector or not isinstance(selector, str):
            raise InvalidActionError("Selector must be a non-empty string for assert_element.")
        params: Dict[str, Any] = {"selector": selector, "exists": bool(exists)}
        if is_visible is not None:
            params["isVisible"] = bool(is_visible)
        return self._add_step(actions.ASSERT_ELEMENT, params)

    def assert_text(self, text_to_find: str, selector: Optional[str] = None, should_contain: bool = True, is_case_sensitive: bool = False) -> 'WorkflowBuilder':
        """
        Adds an assertion step for text content on the page or within a specific element.
        Assumes Stagehand supports such assertion actions.

        Args:
            text_to_find (str): The text to search for.
            selector (Optional[str]): If provided, checks for text within the element(s) 
                                    matching this CSS selector. If None, Stagehand might 
                                    check the entire page's visible text (behavior 
                                    dependent on Stagehand).
            should_contain (bool): Optional (default=True). 
                                 If True, asserts the text is found (contained).
                                 If False, asserts the text is NOT found (not contained).
            is_case_sensitive (bool): Optional (default=False). If True, the text match 
                                    is case-sensitive.

        Returns:
            WorkflowBuilder: The WorkflowBuilder instance for method chaining.

        Raises:
            InvalidActionError: If `text_to_find` is not a string or `selector` is 
                              invalid (if provided).
        """
        if not isinstance(text_to_find, str):
            raise InvalidActionError("text_to_find must be a string for assert_text.")
        params: Dict[str, Any] = {"text": text_to_find, "contains": bool(should_contain), "caseSensitive": bool(is_case_sensitive)}
        if selector is not None:
            if not isinstance(selector, str) or not selector.strip():
                raise InvalidActionError("Selector must be a non-empty string if provided for assert_text.")
            params["selector"] = selector.strip()
        return self._add_step(actions.ASSERT_TEXT, params)

    def build(self) -> Dict[str, Any]:
        """
        Constructs the final workflow definition payload for Stagehand.
        Performs basic validation before returning.
        """
        if not self._steps:
            # Depending on Stagehand, an empty steps list might be valid for a named workflow
            # or it might be an error. For MVP, let's enforce at least one step.
            raise WorkflowValidationError("Cannot build an empty workflow. Add at least one step.")

        # This structure MUST match what StagehandClient.create_task expects for its payload.
        return {
            "name": self.workflow_name,
            "steps": self._steps
        }

    def get_steps_payload(self) -> List[Dict[str, Any]]:
        """Returns a copy of the internal list of step dictionaries as structured for Stagehand."""
        return list(self._steps) # Return a copy to prevent external modification

    def to_readable_steps(self) -> List[str]:
        """
        Generates a list of human-readable strings representing the workflow steps.
        Useful for debugging or logging the defined workflow.

        Returns:
            A list of strings, each describing a step.
        """
        readable = []
        for i, step in enumerate(self._steps):
            action_type = step.get("actionType", "UNKNOWN_ACTION")
            params = {k: v for k, v in step.items() if k not in ["type", "actionType"]}
            param_str = ", ".join([f"{k}='{v}'" if isinstance(v, str) else f"{k}={v}" for k, v in params.items()])
            readable.append(f"{i+1}. {action_type.upper()}: {param_str}")
        return readable

    def __repr__(self) -> str:
        """Provides an informative string representation of the WorkflowBuilder instance."""
        num_steps_to_show = 3
        step_previews_list = []
        if self._steps:
            for i, step in enumerate(self._steps[:num_steps_to_show]):
                action_type = step.get("actionType", "?")
                step_previews_list.append(action_type)
            if len(self._steps) > num_steps_to_show:
                step_previews_list.append("...")
        
        joined_previews = ", ".join(step_previews_list)
        preview_str = f", initial_actions=[{joined_previews}]" if step_previews_list else ""
        return f"WorkflowBuilder(workflow_name='{self.workflow_name}', steps={len(self._steps)}{preview_str})" 
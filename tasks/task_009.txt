# Task ID: 9
# Title: Implement CLI Interface
# Status: pending
# Dependencies: 4, 5, 6, 7
# Priority: medium
# Description: Create a command-line interface for running data collection, processing, and dataset building tasks.
# Details:
1. Create a `cli.py` module using Click or Typer
2. Implement commands for:
   - `collector run --site SITE --workflow WORKFLOW` - Run data collection
   - `processor run --job JOB_TYPE` - Run processing jobs
   - `dataset build` - Build JSONL datasets
   - `eval run --benchmark BENCHMARK` - Run evaluations
3. Add configuration options for all commands
4. Implement progress bars and rich terminal output
5. Add logging configuration
6. Create help documentation for all commands

Example usage:
```bash
# Run data collection
python -m browser_agent_dataset.cli collector run --site youtube --workflow video_discovery_v1 --sessions 5

# Build dataset
python -m browser_agent_dataset.cli dataset build --output train.jsonl
```

# Test Strategy:
Unit tests for CLI argument parsing and command routing. Integration tests for each command with minimal configurations. Test help output and error handling. Verify logging works correctly at different verbosity levels.

# Subtasks:
## 1. Design CLI Structure and Command Framework [done]
### Dependencies: None
### Description: Define the overall CLI architecture, command structure, and establish conventions for command naming and organization.
### Details:
Create a blueprint for CLI organization with resources and aliases. Follow established CLI conventions. Plan for human-readable output with JSON support for automation. Consider future extensibility.
<info added on 2025-05-14T17:23:25.168Z>
The CLI structure will be designed with the following approach:

1. Research and select an appropriate Python CLI framework, with preference for Click or Typer due to their modern features and support for nested commands.

2. Define core command groups that align with the project workflow:
   - configure: For setting up credentials and environment
   - collect: For data collection workflows
   - process: For data processing operations
   - dataset: For dataset building and management
   - finetune: For model fine-tuning operations
   - evaluate: For running evaluation benchmarks
   - storage: For managing data storage

3. Establish consistent naming conventions:
   - Use kebab-case for commands and subcommands
   - Standardize option naming patterns
   - Create clear, concise help documentation

4. Organize code in a modular structure:
   - Create separate modules for each command group
   - Establish a clear entry point
   - Design for extensibility

5. Implement robust error handling and logging:
   - Define error reporting standards
   - Support configurable verbosity levels

6. Design configuration management:
   - Support config files and environment variables
   - Create a dedicated configuration command

7. Document all design decisions in a markdown file to guide implementation of subsequent CLI tasks.

The CLI will follow established conventions while providing both human-readable output and JSON support for automation. The design will prioritize future extensibility and maintainability.
</info added on 2025-05-14T17:23:25.168Z>

## 2. Implement Core Scaffolding Functionality [done]
### Dependencies: 9.1
### Description: Develop the primary scaffolding engine that will generate project templates and code structures.
### Details:
Build the core template generation system. Create standard templates for common components. Implement template variable substitution. Ensure templates follow best practices and are easily customizable.
<info added on 2025-05-14T17:24:16.086Z>
Build the core template generation system. Create standard templates for common components. Implement template variable substitution. Ensure templates follow best practices and are easily customizable.

Implementation Plan:
1. Add `typer[all]` to `requirements.txt` to enable full CLI features including shell completion
2. Create the CLI directory structure:
   - `src/bad_agent_cli/` as the main directory
   - `src/bad_agent_cli/__init__.py` for package initialization
   - `src/bad_agent_cli/main.py` to serve as the main Typer application entry point

3. Implement a basic Typer application in `main.py`:
   - Initialize the Typer app
   - Add a version command (`bad-agent --version`)
   - Set up the command structure

4. Configure the project entry point in `pyproject.toml`:
   - Add `[project.scripts]` section
   - Set `bad-agent = "bad_agent_cli.main:app"` to make the CLI accessible

5. Create modules for command groups:
   - `src/bad_agent_cli/configure_cli.py` for configuration commands
   - `src/bad_agent_cli/collect_cli.py` for collection commands
   - Implement placeholder Typer apps/functions initially

6. Register subcommands in `main.py`:
   - Import sub-module Typer apps
   - Register them with the main app (e.g., `app.add_typer(configure_cli.app, name="configure")`)

7. Implement initial commands:
   - Add `configure init` command in `configure_cli.py`
   - Add `collect list-workflows` command in `collect_cli.py`
   - Start with placeholder functionality

8. Test installation and functionality:
   - Install with `pip install -e .`
   - Test commands: `bad-agent --help`, `bad-agent configure init`, `bad-agent collect list-workflows`

9. Create basic CLI tests:
   - Set up `tests/cli/` directory and `tests/cli/test_main.py`
   - Use `Typer.testing.CliRunner` for command invocation tests
   - Verify basic command structure and responses
</info added on 2025-05-14T17:24:16.086Z>

## 3. Develop Configuration Management System [done]
### Dependencies: 9.1
### Description: Create a robust configuration system that handles user preferences, project settings, and template customization options.
### Details:
Implement configuration file loading/saving. Support for multiple configuration formats. Create sensible defaults. Allow for project-specific and global configurations.
<info added on 2025-05-14T18:18:39.553Z>
The configuration management system will be implemented using Pydantic-settings for type safety and multi-source loading capabilities. The system will:

1. Define a configuration schema as a Pydantic model with key settings including:
   - API keys (BROWSERBASE_API_KEY, STAGEHAND_API_KEY)
   - S3 configuration (keys, bucket, endpoint)
   - DEFAULT_OUTPUT_DIR
   - LOG_LEVEL

2. Implement a priority-based configuration loading strategy:
   - Environment variables (highest priority)
   - Project .env file
   - With architecture supporting future extension to user-level config files

3. Create a dedicated settings module (src/bad_agent_cli/config.py) that:
   - Defines AppSettings class extending BaseSettings
   - Configures SettingsConfigDict for .env loading
   - Provides a singleton settings instance

4. Integrate with the CLI's configure command:
   - Update src/bad_agent_cli/configure_cli.py
   - Implement init command to check/guide creation of .env files
   - Generate .env.example with placeholder keys

5. Ensure proper dependency management:
   - Add pydantic-settings to requirements.txt
   - Update .gitignore to exclude .env files

6. Implement a simple API for accessing configuration:
   - Allow importing settings from anywhere in the codebase
   - Provide consistent access patterns for configuration values

7. Add comprehensive tests:
   - Test configuration loading with mocked environment variables and files
   - Verify configure init command behavior
   - Test configuration priority resolution
</info added on 2025-05-14T18:18:39.553Z>

## 4. Build Progress Tracking and Logging System [done]
### Dependencies: 9.1
### Description: Implement comprehensive logging and progress reporting for CLI operations.
### Details:
Create a logging system with multiple verbosity levels. Implement progress indicators for long-running tasks. Design error reporting that fails noisily and as early as possible. Support both human-readable and machine-parseable output formats.
<info added on 2025-05-14T18:22:16.782Z>
Create a logging system with multiple verbosity levels. Implement progress indicators for long-running tasks. Design error reporting that fails noisily and as early as possible. Support both human-readable and machine-parseable output formats.

Implementation Plan:
1. Basic Logging Configuration:
   - Create a `setup_logging()` function in `src/bad_agent_cli/main.py`
   - Call this function from `main_callback` to initialize logging early
   - Configure the root logger level based on `settings.LOG_LEVEL`
   - Implement a simple formatter and attach a `StreamHandler` to `sys.stderr`

2. Command-Specific Logging:
   - Add logger instances in command modules (`configure_cli.py`, `collect_cli.py`) using `logging.getLogger(__name__)`
   - Replace appropriate `print()` statements with proper log level calls (`logger.info()`, `logger.debug()`, etc.)
   - Ensure consistent log message formatting across all modules

3. User Feedback Strategy:
   - Maintain `typer.echo()` for direct user-facing output
   - Use `logger.error()`/`logger.exception()` for error conditions
   - Complement error logging with `typer.secho()` for highlighted user feedback
   - Ensure clear separation between diagnostic logs and user interface elements

4. Testing Approach:
   - Create tests in existing test files or a new `test_logging.py`
   - Utilize pytest's `caplog` fixture to verify log output
   - Validate that `LOG_LEVEL` setting properly controls log verbosity
   - Test error conditions to ensure proper logging and user feedback

5. Future Considerations:
   - File logging support as a post-MVP enhancement
   - Progress bar integration for long-running operations
   - JSON output format option for machine parsing
</info added on 2025-05-14T18:22:16.782Z>

## 5. Create Comprehensive Help Documentation [done]
### Dependencies: 9.1, 9.2, 9.3
### Description: Develop in-tool help documentation and usage guides for all commands and options.
### Details:
Document all public flags and options. Create command-specific help text. Implement examples for common use cases. Ensure help text follows consistent formatting and style.
<info added on 2025-05-14T18:25:18.249Z>
Document all public flags and options. Create command-specific help text. Implement examples for common use cases. Ensure help text follows consistent formatting and style.

Implementation plan:
1. Review auto-generated help by systematically invoking `--help` for all commands and subcommands to check clarity and completeness of descriptions for commands, arguments, and options.
2. Enhance docstrings and help texts by updating docstrings in `main.py`, `configure_cli.py`, and `collect_cli.py` as needed, and refining `help` parameters in `typer.Option()` and `typer.Argument()` calls for better clarity.
3. Verify `no_args_is_help=True` behavior to confirm that invoking a command group without a subcommand displays its help.
4. Test help output robustly by adding assertions in `tests/cli/test_main.py` or a new `test_help.py` that check for specific content/keywords in the `--help` output for each command, beyond just the exit code.
5. Ensure all help documentation follows a consistent style guide and formatting pattern.
6. Include practical examples for each command that demonstrate common use cases and workflows.
7. Document any environment variables or configuration files that affect CLI behavior.
</info added on 2025-05-14T18:25:18.249Z>

## 6. Implement Testing Framework [pending]
### Dependencies: 9.2, 9.3, 9.4
### Description: Develop comprehensive testing infrastructure for CLI functionality and generated code.
### Details:
Create unit tests for core functionality. Implement integration tests for end-to-end workflows. Develop validation tests for generated code. Set up CI integration for automated testing.

## 7. Finalize CLI Implementation and Documentation [pending]
### Dependencies: 9.2, 9.3, 9.4, 9.5, 9.6
### Description: Complete the CLI implementation, perform final testing, and prepare comprehensive external documentation.
### Details:
Conduct final review of all commands and options. Ensure proper exit codes are used. Verify all error handling. Create external documentation including README, installation guide, and advanced usage examples.

